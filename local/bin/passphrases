#!/bin/bash

set -eu

if ! command -v xkcdpass >/dev/null 2>&1; then
    echo 'xkcdpass is not installed on this system!'
    exit 1
fi

if ! command -v sponge >/dev/null 2>&1; then
    echo 'sponge (moreutils package) is not installed on this system!'
    exit 1
fi

if ! command -v bc >/dev/null 2>&1; then
    echo 'bc is not installed on this system!'
    exit 1
fi

if ! [ -f "$HOME/.local/lib/bc.d/ceil.bc" ]; then
    echo 'bc is missing ceil function file.'
    exit 1
fi

if [[ $BC_ENV_ARGS != *"ceil.bc"* ]]; then
    echo 'BC_ENV_ARGS is missing ceil file reference.'
    exit 1
fi

WORD_COUNT=4
# DELIMITER_TYPE=--delimiter=-
DELIMITER_TYPE=(--random-delimiters --valid-delimiters='23456789')
# DELIMITER_TYPE=(--random-delimiters --valid-delimiters='23456789%&*-+$')
EXPECTED_DELIMITER_COUNT=$((WORD_COUNT - 1))
# CASE_TYPE=--case=lower # Or "random" for more entropy
CASE_TYPE=--case=lower
# Use caution when changing the max word size.
# As shown below, every step down cuts the wordlist size by a lot.
# Wordlist size by max chars:
# ≤3chars:   82  (1.0545%)
# ≤4chars:  549  (7.06%)
# ≤5chars: 1477  (19%)
# ≤6chars: 2849  (37%)
# ≤7chars: 4440  (57%)
# ≤8chars: 6219  (80%)
#  9chars: 7776  (100%)
WORD_LENGTH_MAX=9
WORD_LENGTH_MAX_AVG=6.5
# Avoid having passphrases filled with too many long words.
PASSPHRASE_LENGTH=$(echo "scale = 0; ceil( ($WORD_COUNT * $WORD_LENGTH_MAX_AVG)\
+ ($WORD_COUNT - 1) )" | bc -l)

COUNT=15

echo "Running the following command until $COUNT passphrases are generated:"
printf "xkcdpass --count=%s --min=3 --max=%s --numwords=%s %s %s | sponge |" \
    $((COUNT * 3)) $WORD_LENGTH_MAX $WORD_COUNT "${DELIMITER_TYPE[@]}" \
    $CASE_TYPE
echo -n $'\n'"    sed --regexp-extended 's/^[^a-z]//gi; s/[^a-z]$//gi' |"$'\n'
printf '    grep --extended-regexp "([^a-z][a-z]+){%s}"'" |\
 sed '/^.\{'%s',\}$/d' |" $EXPECTED_DELIMITER_COUNT "$PASSPHRASE_LENGTH"
echo -n $'\n'"    grep --extended-regexp"
printf " --invert-match --ignore-case '(.)[^a-z]?\\\1{1}'"$'\n'

passphrases=''
loop_count=0
COUNT_MULTIPLIER=3
# With the amount of extra filtering being done here, xkcdpass needs to generate
# more passwords than the amount ultimately shown. The exact number will vary
# due to randomness so we just keep running the command until we have enough.
while [[ $(echo -n "$passphrases" | wc -l) -le $COUNT ]]; do
    loop_count=$((loop_count + 1))
    new_passphrases=$(xkcdpass --count=$((COUNT * COUNT_MULTIPLIER)) --min=3 \
        --max=$WORD_LENGTH_MAX --numwords=$WORD_COUNT \
        "${DELIMITER_TYPE[@]}" $CASE_TYPE |
        # Filtering commands require the entire list to be sent together instead
        # of the stream xkcdpass outputs
        sponge |
        # Remove separators from the beginning/end of each passphrase
        sed --regexp-extended 's/^[^a-z]//gi; s/[^a-z]$//gi' |
        # Make sure passphrase always contains delimiters when
        # "random-delimiters" flag decides to omit them.
        grep --extended-regexp "([^a-z][a-z]+){$EXPECTED_DELIMITER_COUNT}" |
        # Exclude results with too many long words (based on average word len)
        sed '/^.\{'"$PASSPHRASE_LENGTH"',\}$/d' |
        # Exclude results with double letters sequentially, even if there's a
        # separator between them.
        grep --extended-regexp --invert-match --ignore-case '(.)[^a-z]?\1{1}' |
        # This extra cat is required for some reason.
        cat)
    if [[ ${#new_passphrases} -gt 0 ]]; then
        if [[ ${#passphrases} -gt 0 ]]; then
            passphrases="$passphrases"$'\n'"$new_passphrases"
        else
            passphrases="$new_passphrases"
        fi
    fi
done
gen_count=$((loop_count * COUNT * COUNT_MULTIPLIER))
echo "Generated $gen_count passphrases in total to get this list:"
echo "$passphrases" | head -n$COUNT
